#ifndef FORTEST_FORTRAN_TEST_PREPROCESSOR_HPP
#define FORTEST_FORTRAN_TEST_PREPROCESSOR_HPP

#include <string>
#include <string_view>
#include <regex>
#include <sstream>
#include <unordered_map>
#include <stdexcept>
#include "preprocessor_base.hpp"

namespace Fortest {
    /**
     * @brief Fortran test preprocessor with scope-aware fixture handling.
     *
     * Transforms `@test` subroutines into wrappers that take
     * `(t_ptr, ts_ptr, s_ptr)` and dereference only the fixtures
     * that are actually declared, based on a scope map.
     */
    class FortranTestPreprocessor : public PreprocessorBase<FortranTestPreprocessor> {
    public:
        explicit FortranTestPreprocessor(
            std::unordered_map<std::string, std::string> scope_map)
            : m_scope_map(std::move(scope_map)) {
        }

        /// @brief Transform Fortran source code with `@test` subroutines.
        std::string transform(const std::string &code) {
            // Regex: captures name, arg list, body
            static const std::regex re(
                R"(subroutine\s+(\w+)\s*\(([^)]*)\)([\s\S]*?)end\s+subroutine\s+\1)",
                std::regex::icase
            );

            std::ostringstream out;

            std::sregex_iterator it(code.begin(), code.end(), re);
            std::sregex_iterator end;

            // Track the last consumed position
            std::size_t last_pos = 0;

            for (; it != end; ++it) {
                auto &match = *it;

                // Write any code before this subroutine unchanged
                out << code.substr(last_pos, match.position() - last_pos);

                std::string name = match[1];
                std::string args = match[2];
                std::string body = match[3];

                out << generate_wrapper(name, args, body);

                // Advance last_pos
                last_pos = match.position() + match.length();
            }

            // Write any trailing text after the last subroutine
            out << code.substr(last_pos);

            return out.str();
        }
        std::string generate_wrapper(const std::string &name,
                             const std::string & /*args*/,
                             const std::string &body) {
    std::ostringstream out;

    // Collect fixture info
    std::vector<std::string> fixture_decls;
    std::vector<std::string> deref_calls;
    std::string impl_args;

    if (body.find("test_fixture_t") != std::string::npos) {
        fixture_decls.push_back("   type(test_fixture_t), pointer :: t");
        deref_calls.push_back("   call c_f_pointer(t_ptr, t)");
        if (!impl_args.empty()) impl_args += ", ";
        impl_args += "t";
    }
    if (body.find("suite_fixture_t") != std::string::npos) {
        fixture_decls.push_back("   type(suite_fixture_t), pointer :: ts");
        deref_calls.push_back("   call c_f_pointer(ts_ptr, ts)");
        if (!impl_args.empty()) impl_args += ", ";
        impl_args += "ts";
    }
    if (body.find("session_fixture_t") != std::string::npos) {
        fixture_decls.push_back("   type(session_fixture_t), pointer :: s");
        deref_calls.push_back("   call c_f_pointer(s_ptr, s)");
        if (!impl_args.empty()) impl_args += ", ";
        impl_args += "s";
    }

    // Outer wrapper
    out << " !> @test " << name << " autogenerated test wrapper.\n";
    out << "subroutine " << name << "(t_ptr, ts_ptr, s_ptr)\n";
    out << "   type(c_ptr), value :: t_ptr, ts_ptr, s_ptr\n\n";

    for (auto &decl : fixture_decls) out << decl << "\n";
    out << "\n";
    for (auto &deref : deref_calls) out << deref << "\n";

    out << "   call " << name << "_impl(" << impl_args << ")\n";

    // Inner impl
    out << "contains\n";
    out << "   subroutine " << name << "_impl(" << impl_args << ")\n";

    {
        std::istringstream in(body);
        std::string line;
        while (std::getline(in, line)) {
            if (line.find("type(") != std::string::npos) continue;      // skip decls
            if (line.find("c_f_pointer") != std::string::npos) continue; // skip derefs
            if (line.find("end subroutine") != std::string::npos) continue; // skip old end
            out << line << "\n";
        }
    }

    out << "   end subroutine " << name << "_impl\n";
    out << "end subroutine " << name << "\n\n";

    return out.str();
}


    private:
        std::unordered_map<std::string, std::string> m_scope_map;
        std::regex m_test_re{
            R"(@test\s*subroutine\s+(\w+)\s*\(([^)]*)\)([\s\S]*?)end\s+subroutine\s+\1)",
            std::regex::icase
        };


        /// @brief Insert c_f_pointer calls for declared fixture types.
        void add_fixture_derefs(std::ostringstream &out, const std::string &body) {
            for (auto &[fixture_type, scope]: m_scope_map) {
                if (body.find(fixture_type) != std::string::npos) {
                    if (scope == "test") {
                        out << "      call c_f_pointer(t_ptr, t)\n";
                    } else if (scope == "suite") {
                        out << "      call c_f_pointer(ts_ptr, ts)\n";
                    } else if (scope == "session") {
                        out << "      call c_f_pointer(s_ptr, s)\n";
                    }
                }
            }
        }

        /// @brief Trim whitespace from both ends of a string.
        static std::string trim(const std::string &s) {
            size_t start = s.find_first_not_of(" \t\n\r");
            size_t end = s.find_last_not_of(" \t\n\r");
            if (start == std::string::npos) return "";
            return s.substr(start, end - start + 1);
        }
    };
}

#endif //FORTEST_FORTRAN_TEST_PREPROCESSOR_HPP
